/**
 * V2 Lighter Data Collector
 * 
 * Standalone data collection for Lighter funding rates
 * Stores raw data in separate table (lighter_raw_data)
 * Does NOT integrate with existing market_history tables
 * 
 * Runs hourly via cron job
 */

import { Env } from './types';

interface LighterMarket {
  market_id: number;
  symbol: string;
  status: string;
}

interface LighterFunding {
  timestamp: number;
  value: string;
  rate: string;
  direction: 'long' | 'short';
}

interface LighterFundingsResponse {
  fundings: LighterFunding[];
}

/**
 * Main collection function - fetches and stores Lighter funding data
 * Uses dynamic lookback based on last timestamp in database
 */
export async function collectLighterData(env: Env): Promise<void> {
  console.log('[V2 Lighter] Starting data collection');

  // Update market metadata
  await updateMarketMetadata(env);

  // Fetch active markets
  const markets = await fetchActiveMarkets();
  console.log(`[V2 Lighter] Found ${markets.length} active markets`);

  // Get last timestamp from database to determine lookback
  const lastTimestamp = await env.DB_WRITE.prepare(
    'SELECT MAX(timestamp) as last_ts FROM lighter_raw_data'
  ).first<{last_ts: number}>();

  const now = Math.floor(Date.now() / 1000);
  let startTimestamp: number;

  if (lastTimestamp?.last_ts) {
    // Start from last timestamp minus 1 hour buffer to catch any missed data
    startTimestamp = Math.floor(lastTimestamp.last_ts / 1000) - 3600;
    const hoursBack = (now - startTimestamp) / 3600;
    console.log(`[V2 Lighter] Using dynamic lookback: ${hoursBack.toFixed(1)} hours`);
  } else {
    // No data yet, use 24 hour default
    startTimestamp = now - (24 * 60 * 60);
    console.log('[V2 Lighter] No existing data, using 24 hour lookback');
  }

  let totalRecords = 0;
  const batchSize = 10;
  
  for (let i = 0; i < markets.length; i += batchSize) {
    const batch = markets.slice(i, i + batchSize);
    const batchPromises = batch.map(market => 
      collectMarketData(env, market, startTimestamp, now)
    );
    
    const results = await Promise.allSettled(batchPromises);
    
    results.forEach((result, idx) => {
      if (result.status === 'fulfilled') {
        totalRecords += result.value;
      } else {
        console.error(`[V2 Lighter] Failed to collect ${batch[idx].symbol}:`, result.reason);
    for (let i = 0; i < markets.length; i += batchSize) {
      const batch = markets.slice(i, i + batchSize);
      const batchPromises = batch.map(market => 
        collectMarketData(env, market, twoHoursAgo, now)
      );
      
      const results = await Promise.allSettled(batchPromises);
      
      results.forEach((result, idx) => {
        if (result.status === 'fulfilled') {
          totalRecords += result.value;
        } else {
          console.error(`[V2 Lighter] Failed to collect ${batch[idx].symbol}:`, result.reason);
        }
      });
      
      if (i + batchSize < markets.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    const duration = Date.now() - startTime;
    await updateTrackerStatus(env, 'idle', null);
    await incrementTrackerStats(env, totalRecords);

    console.log(`[V2 Lighter] Collection complete: ${totalRecords} records in ${duration}ms`);

  } catch (error) {
    console.error('[V2 Lighter] Collection failed:', error);
    const errorMsg = error instanceof Error ? error.message : 'Unknown error';
    await updateTrackerStatus(env, 'error', errorMsg);
    throw error;
  }
}

/**
 * Fetch active markets from Lighter API
 */
async function fetchActiveMarkets(): Promise<LighterMarket[]> {
  const response = await fetch('https://mainnet.zklighter.elliot.ai/api/v1/orderBooks');
  
  if (!response.ok) {
    throw new Error(`Failed to fetch markets: ${response.status}`);
  }

  const data = await response.json() as { order_books: LighterMarket[] };
  return data.order_books.filter(m => m.status === 'active');
}

/**
 * Update market metadata
 */
async function updateMarketMetadata(env: Env, markets: LighterMarket[]): Promise<void> {
  const now = Math.floor(Date.now() / 1000);
  
  const statements = markets.map(market => 
    env.DB_WRITE.prepare(`
      INSERT OR REPLACE INTO lighter_markets (market_id, symbol, status, last_updated)
      VALUES (?, ?, ?, ?)
    `).bind(market.market_id, market.symbol, market.status, now)
  );

  await env.DB_WRITE.batch(statements);
  console.log(`[V2 Lighter] Updated ${markets.length} markets`);
}

/**
 * Collect funding data for a single market
 */
async function collectMarketData(
  env: Env,
  market: LighterMarket,
  startTimestamp: number,
  endTimestamp: number
): Promise<number> {
  try {
    const url = `https://mainnet.zklighter.elliot.ai/api/v1/fundings?market_id=${market.market_id}&resolution=1h&start_timestamp=${startTimestamp}&end_timestamp=${endTimestamp}&count_back=0`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }

    const data = await response.json() as LighterFundingsResponse;

    if (!data.fundings || data.fundings.length === 0) {
      return 0;
    }

    const collectedAt = Math.floor(Date.now() / 1000);
    const recentData = data.fundings.map(item => ({
      symbol: market.symbol,
      timestamp: item.timestamp,
      value: item.value,
      rate: item.rate,
      direction: item.direction
    }));

    const statements = recentData.map(item => {
      const rate = parseFloat(item.rate);
      const signedRate = item.direction === 'short' ? -rate : rate;
      const rateAnnual = signedRate * 24 * 365;
      // IMPORTANT: Multiply timestamp by 1000 (Lighter API returns seconds, not milliseconds)
      const timestampMs = item.timestamp * 1000;
      const cumulativeValue = parseFloat(item.value);

      return env.DB_WRITE.prepare(
        'INSERT OR REPLACE INTO lighter_raw_data (market_id, symbol, timestamp, rate, rate_annual, direction, cumulative_value, collected_at, source) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)'
      ).bind(
        market.market_id,
        item.symbol,
        timestampMs,
        signedRate,
        rateAnnual,
        item.direction,
        cumulativeValue,
        collectedAt,
        'api'
      );
    });

    await env.DB_WRITE.batch(statements);

    console.log(`[V2 Lighter] ${market.symbol}: ${data.fundings.length} records`);
    return data.fundings.length;

  } catch (error) {
    console.error(`[V2 Lighter] Error collecting ${market.symbol}:`, error);
    return 0;
  }
}

/**
 * Update tracker status
 */
async function updateTrackerStatus(
  env: Env,
  status: 'idle' | 'running' | 'error',
  error: string | null
): Promise<void> {
  const now = Math.floor(Date.now() / 1000);
  
  if (status === 'idle' || status === 'running') {
    await env.DB_WRITE.prepare(`
      UPDATE lighter_tracker_status 
      SET status = ?, last_run = ?, last_success = ?, last_error = NULL
      WHERE id = 1
    `).bind(status, now, now).run();
  } else {
    await env.DB_WRITE.prepare(`
      UPDATE lighter_tracker_status 
      SET status = ?, last_run = ?, last_error = ?
      WHERE id = 1
    `).bind(status, now, error).run();
  }
}

/**
 * Increment tracker statistics
 */
async function incrementTrackerStats(env: Env, recordCount: number): Promise<void> {
  await env.DB_WRITE.prepare(`
    UPDATE lighter_tracker_status 
    SET total_runs = total_runs + 1, total_records = total_records + ?
    WHERE id = 1
  `).bind(recordCount).run();
}
